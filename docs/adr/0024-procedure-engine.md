# ADR-0024: Procedure Engine — Declarative DSL for Business Logic

**Status:** Accepted
**Date:** 2026-02-15
**Participants:** @roman_myakotin

## Context

### Problem: business logic requires developers

The platform is metadata-driven (ADR-0003, ADR-0007): objects, fields, validation, defaults are defined declaratively. Security (OLS/FLS/RLS — ADR-0009..0012) and DML Pipeline (ADR-0020) provide secure data access. However, **procedural business logic** — action chains, integrations, conditional notifications — still requires Go code:

| What exists (declaratively) | What is missing |
|---|---|
| Field validation (Validation Rules, ADR-0019) | Action chains: create record -> send email -> call API |
| Dynamic defaults (Default Expressions) | Conditional logic: if amount > 10K -> request approval |
| Buttons on the record card (Object View, ADR-0022) | Compensating actions: rollback on error (Saga) |
| Action types (ADR-0023: navigate, field_update) | Synchronous and asynchronous processes |

Every business process change (new notification, external system integration, routing condition) requires a development cycle: code -> review -> deploy. Typical changes take 2-5 days instead of 15 minutes.

### Terminology (ADR-0023)

This ADR uses the terminology established in ADR-0023:

| Term | Definition |
|------|-----------|
| **Procedure** | Named set of Commands, described declaratively (JSON + CEL). Executed synchronously |
| **Command** | Atomic operation inside a Procedure: `record.create`, `notification.email`, `integration.http` |
| **Command Type** | Category of command: `record.*`, `notification.*`, `integration.*`, `compute.*`, `flow.*`, `wait.*` |
| **Action** | Umbrella term; Procedure is one of the action types (`type: procedure`) |

### Industry Context

| Platform | Declarative logic | Expression Language | Sandbox | UI |
|----------|-------------------|---------------------|---------|-----|
| **Salesforce** | Flow Builder (visual) + Apex (code) | Formula | Partial (Apex limits) | Drag-and-drop builder |
| **Dynamics 365** | Power Automate (low-code) | Power Fx | Yes | Visual + form builder |
| **ServiceNow** | Workflow Designer | JavaScript (scoped) | Partial | Form-based constructor |
| **Zapier/n8n** | Visual workflow | JS / expressions | No | Visual node editor |

All platforms provide a visual interface for building business logic. Administrators do not write code — they assemble procedures from ready-made blocks through UI. The text format (JSON/YAML) is an internal representation, not a user interface.

### Requirements

1. Administrators create and modify procedural logic through a **visual constructor** without knowledge of DSL
2. Security by design: no loops, arbitrary code, file I/O
3. CEL as the unified expression language (already used in Phase 7b for validation rules and defaults)
4. **JSON** as the storage format — native support in Go, PostgreSQL (JSONB), TypeScript
5. Compensating actions (Saga pattern) for distributed operations
6. Calling one procedure from another with depth control
7. Full observability: logging, metrics, tracing of every command
8. Dry-run and declarative tests without side effects

## Considered Options

### Option A — Imperative Go Code per Business Rule (status quo)

Each business rule is implemented as a Go function in the service layer. New rules are added through a development cycle.

**Pros:**
- Full control and maximum performance
- Compile-time type safety
- Familiar approach for Go developers

**Cons:**
- Every change requires a developer (2-5 days instead of 15 minutes)
- Administrators are entirely dependent on the development team
- No standardization: each developer writes differently
- Audit complexity: need to read Go code to understand business logic

### Option B — Embedded Scripting Engine (JavaScript/Starlark sandbox)

Provide administrators with a sandbox environment for writing scripts in a familiar language.

**Pros:**
- Maximum expression flexibility
- JavaScript is familiar to many administrators
- Starlark (Google) — sandbox by design, deterministic

**Cons:**
- Two expression languages: CEL (validation, defaults) + JS/Starlark (procedures)
- JavaScript sandbox (V8/QuickJS) is heavy, hard to fully restrict
- Scripts are harder to analyze statically than JSON structures
- Security: even in a sandbox, timing attacks and resource exhaustion are possible

### Option C — JSON DSL + Constructor UI + CEL (chosen)

Procedural logic is stored as JSON (JSONB in PostgreSQL). The administrator assembles a procedure through a **form-based Constructor** — selects command type from a list, fills in parameters, builds expressions through Expression Builder. JSON is generated by the constructor automatically. Power users can edit JSON directly.

**Pros:**
- **Constructor-first**: zero entry barrier for administrators — no need to know JSON/DSL
- **JSON is native** to the entire stack: `encoding/json` (Go), JSONB (PostgreSQL), TypeScript — no additional parsers
- **JSONB in PostgreSQL**: indexing, GIN indexes, jsonpath queries, partial updates
- Reuse of CEL — unified expression language from UI to backend
- Security by design: fixed set of command types, no loops
- Static analysis: JSON schema allows validating procedure on save
- Extensibility: new command types are added in Go, immediately available in Constructor
- Dry-run and declarative tests out of the box

**Cons:**
- Limited flexibility: cannot express arbitrary algorithms
- JSON is less readable for humans than YAML — but the administrator works through Constructor, not reading JSON
- For non-standard scenarios, a new command type in Go is needed

### Option D — Visual Flow Builder (drag-and-drop graph)

Graphical flow editor, analogous to Salesforce Flow Builder or n8n.

**Pros:**
- Visual clarity: visual process diagram
- Popular approach in enterprise CRM

**Cons:**
- Versioning complexity: visual model is stored as a JSON graph, diff is unreadable
- Merge conflicts are practically unresolvable
- Significant frontend investment (canvas editor, node rendering, edge routing)
- Overkill for linear procedures (80% of cases — sequential commands)
- Form-based Constructor is simpler to implement and covers the same cases
- Visual Builder can be added on top of JSON DSL as an alternative UI in the future

## Decision

**Option C chosen: JSON DSL + Constructor UI + CEL.**

Procedure Engine is a runtime for executing named Procedures described in JSON. The administrator assembles procedures through the **Constructor UI**. JSON is the internal representation (IR), stored as JSONB in PostgreSQL. CEL is the unified expression language.

### Architecture: Constructor -> JSON -> Engine

```
Administrator -> Constructor UI -> JSON (JSONB) -> Procedure Engine
                                      ^
Power user -> Raw JSON editor ---------+
```

Constructor UI is the **primary** interface. Raw JSON editor is for power users and debugging. The administrator does not need to know either the JSON structure or CEL syntax — the constructor provides forms, dropdowns, and expression builder.

### Procedure Structure

```json
{
  "name": "create_customer",
  "commands": [
    {
      "type": "record.create",
      "object": "Account",
      "data": {
        "email": "$.input.email",
        "name": "$.input.name"
      },
      "as": "account"
    },
    {
      "type": "notification.email",
      "to": "$.input.email",
      "template": "welcome",
      "data": {
        "name": "$.input.name"
      }
    }
  ],
  "result": {
    "accountId": "$.account.id"
  }
}
```

A Procedure consists of:
- **name** — unique identifier (snake_case)
- **commands** — ordered list of commands
- **result** — CEL mapping that forms the return value

### Constructor UI

#### Procedure Constructor

Form-based interface for building procedures:

1. **Adding a command**: "+" button -> select command type from a categorized dropdown:
   - Data: Create record, Update record, Delete record, Find records
   - Notifications: Email, SMS, Push
   - Integrations: HTTP request, Webhook
   - Logic: Transform, Validate, Error
   - Flow: Call procedure, Start scenario

2. **Configuring a command**: form with fields corresponding to the command type:
   - Dropdown for object selection (for `record.*`)
   - Field mapping table: field -> value/expression
   - CEL expression via Expression Builder (`fx` button)
   - Toggle for `optional`, `as` (save result)

3. **Conditional logic**: "Condition" toggle -> Expression Builder for `when`
   - `if/else`: visual block with two branches
   - `match`: list of cases -> commands

4. **Rollback**: "Rollback on error" toggle -> form for the compensating command

5. **Ordering**: drag-and-drop for reordering commands

6. **Preview**: generated JSON (read-only) + dry-run

#### Expression Builder

Visual CEL expression constructor, applicable across all platform subsystems (Procedure, Validation Rules, Default Expressions, Object View `visibility_expr`, Scenario `when`):

1. **Field picker**: tree of available variables
   - `$.input.*` — input parameters
   - `$.user.*` — current user (id, role, profile)
   - `$.<step>.*` — results of previous commands
   - `$.now` — current time
   - Context fields: `record.*` (for validation rules), `old.*`/`new.*` (for automation)

2. **Operator picker**: typed operators
   - Comparison: `=`, `!=`, `>`, `<`, `>=`, `<=`
   - Logic: `AND`, `OR`, `NOT`
   - Strings: `contains`, `starts with`, `ends with`
   - Lists: `in list`, `not in list`
   - Null: `is empty`, `is not empty`

3. **Function picker**: catalog of functions with descriptions
   - String: `UPPER()`, `LOWER()`, `TRIM()`, `CONCAT()`
   - Numeric: `ABS()`, `ROUND()`, `CEIL()`, `FLOOR()`
   - Date/time: `now()`, `duration()`
   - Collections: `size()`, `has()`
   - Each function with description, parameter types, and example

4. **Live preview**: expression result on sample data in real time

5. **Validation**: syntactic CEL check on input, error highlighting

6. **Dual mode**: visual constructor <-> text CEL (toggle for power users)

### Command Types

| Command Type | Prefix | Commands | Description |
|-------------|--------|----------|-------------|
| **record** | `record.*` | `create`, `update`, `delete`, `get`, `query` | CRUD via DML Engine with OLS/FLS/RLS |
| **notification** | `notification.*` | `email`, `sms`, `push` | Notifications via templates |
| **integration** | `integration.*` | `http` | HTTP calls to external APIs (method in parameters) |
| **compute** | `compute.*` | `transform`, `validate`, `aggregate`, `fail` | Computations and validation |
| **flow** | `flow.*` | `call` (procedure), `start` (scenario) | Invoke procedure / start scenario |
| **wait** | `wait.*` | `signal`, `timer`, `until` | Wait for signal, pause, time |

All `record.*` commands are executed through DML Engine (ADR-0020) with full OLS/FLS/RLS enforcement. A Procedure cannot bypass the security layers.

### Command JSON Schema

Each command is a JSON object with a required `type` field and parameters specific to the command type:

```json
{
  "type": "record.create",
  "object": "Account",
  "data": {
    "email": "$.input.email",
    "name": "$.input.name"
  },
  "as": "account",
  "optional": false,
  "when": "$.input.createAccount",
  "rollback": {
    "type": "record.delete",
    "object": "Account",
    "id": "$.account.id"
  }
}
```

Common fields (for all command types):
- `type` — command type (required)
- `as` — variable name for saving the result
- `optional` — do not abort on error (error -> `$.warnings`)
- `when` — CEL execution condition
- `rollback` — compensating command (Saga)
- `retry` — retry policy

### Context and Variables

All values in a procedure are CEL expressions (strings starting with `$`). The context accumulates as commands execute:

| Variable | Description | Example |
|----------|-------------|---------|
| `$.input` | Procedure input parameters | `$.input.email` |
| `$.user` | Current user | `$.user.id`, `$.user.role` |
| `$.now` | Current UTC time | `$.now` |
| `$.secrets` | **Deprecated** — replaced by Named Credentials (ADR-0028). `integration.http` uses the `credential` field | — |
| `$.<name>` | Result of a command with `as: name` | `$.account.id` |
| `$.warnings` | Array of errors from optional commands | `$.warnings` |
| `$.error` | Current error (in rollback block) | `$.error.code` |

The result of a command is saved via `as` and is available to all subsequent commands until the end of the procedure.

### Conditional Logic

Three forms of conditional execution:

```json
// when — conditional execution of a single command
{
  "type": "notification.email",
  "to": "$.input.email",
  "template": "welcome",
  "when": "$.input.sendWelcome"
}

// if/else — branching
{
  "type": "flow.if",
  "condition": "$.input.amount > 10000",
  "then": [
    {
      "type": "notification.email",
      "to": "\"manager@company.com\"",
      "template": "approval_needed"
    }
  ],
  "else": [
    {
      "type": "compute.transform",
      "data": { "approved": true },
      "as": "decision"
    }
  ]
}

// match — multiple choice
{
  "type": "flow.match",
  "expression": "$.input.priority",
  "cases": {
    "critical": [
      { "type": "notification.email", "to": "\"oncall@company.com\"", "template": "critical_alert" }
    ],
    "high": [
      { "type": "notification.email", "to": "\"team@company.com\"", "template": "high_priority" }
    ]
  },
  "default": [
    { "type": "notification.email", "to": "$.input.assignee_email", "template": "standard_notification" }
  ]
}
```

In the Constructor UI: `if/else` is a visual block with two branches; `match` is a list of variants with an "Add variant" button.

### Error Handling

#### Structured Error

```json
{
  "code": "string",
  "message": "string",
  "details": {},
  "retryable": false,
  "source": "procedure"
}
```

Categories: `validation_*`, `not_found_*`, `permission_*`, `external_*`, `timeout_*`, `limit_*`, `internal_*`.

#### Rollback (Saga Pattern)

Compensating actions are executed in LIFO order when an error occurs in subsequent commands:

```json
{
  "commands": [
    {
      "type": "record.create",
      "object": "Order",
      "data": { "customerId": "$.input.customerId" },
      "as": "order",
      "rollback": {
        "type": "record.delete",
        "object": "Order",
        "id": "$.order.id"
      }
    },
    {
      "type": "integration.http",
      "method": "POST",
      "url": "https://payment.com/charge",
      "body": { "amount": "$.input.amount" },
      "as": "payment",
      "rollback": {
        "type": "integration.http",
        "method": "POST",
        "url": "https://payment.com/refund",
        "body": { "paymentId": "$.payment.id" }
      }
    },
    {
      "type": "notification.email",
      "to": "$.input.email",
      "template": "order_confirmed",
      "data": { "orderId": "$.order.id" }
    }
  ]
}
```

Error in email -> rollback payment -> rollback order (LIFO). Rollback is registered only for successfully executed commands. `$.error` is available in the rollback block.

#### try/catch, retry

```json
// try/catch
{
  "type": "flow.try",
  "commands": [
    {
      "type": "integration.http",
      "method": "POST",
      "url": "https://api.payment.com/charge",
      "body": { "amount": "$.input.amount" },
      "as": "payment"
    }
  ],
  "catch": [
    {
      "type": "compute.fail",
      "code": "payment_error",
      "message": "$.error.message"
    }
  ]
}

// retry
{
  "type": "integration.http",
  "method": "POST",
  "url": "https://api.flaky.com/data",
  "body": { "payload": "$.input.data" },
  "retry": {
    "attempts": 3,
    "delay": "1s",
    "backoff": 2,
    "on": ["timeout", "5xx"]
  }
}
```

### Semantics of call and start

| Aspect | `call` (procedure) | `start` (scenario) |
|--------|-------------------|-------------------|
| Execution | Synchronous | Asynchronous (fire-and-forget) |
| Result | Full result of the called procedure | Only `executionId` |
| Errors | Bubble up to the calling procedure | Do not affect the calling procedure |
| Rollback | Cascading | Independent |
| Context | `$.user`, `$.secrets` are inherited | `$.user` is copied |
| Depth | Maximum 3 levels of nesting | No limit (independent process) |

Cycle protection: the platform tracks the call stack and prevents circular dependencies (`proc_a -> proc_b -> proc_a` = error `circular_procedure_call`).

### Limits

| Parameter | Limit | Description |
|-----------|-------|-------------|
| Execution time | 30 seconds | Maximum time for the entire procedure (excluding wait) |
| Number of commands | 50 | Total including called procedures |
| call nesting | 3 levels | procedure -> procedure -> procedure |
| if/match nesting | 5 levels | Maximum condition depth |
| JSON size | 64 KB | Maximum procedure definition size |
| Input size | 1 MB | Input data |
| Context size | 10 MB | Accumulated context |
| HTTP timeout | 10 seconds | Per single HTTP request |
| HTTP requests | 10 | Maximum in a single procedure |
| Notifications | 10 | Maximum email/sms/push in a single procedure |
| Retry attempts | 3 | Maximum attempts |

When a limit is exceeded, the procedure terminates with a typed error (`limit_exceeded_*`).

### Security Sandbox

| Threat | Protection |
|--------|-----------|
| Infinite loops | Loops are absent in the DSL by design |
| Arbitrary code | Only fixed command types |
| File system access | No I/O operations |
| Uncontrolled HTTP | Only through `integration.http`, with limits |
| RLS/FLS/OLS bypass | All `record.*` commands execute through DML Engine |
| Secret leakage | `$.secrets` is available only at runtime, masked in logs |
| Resource-intensive operations | Strict limits (timeout, command count, data size) |
| Circular calls | Call stack tracking, recursion protection |

### Storage and Versioning

Procedures are stored in PostgreSQL as **JSONB** (table `metadata.procedures`):

| Decision | Rationale |
|----------|-----------|
| JSONB | Native PostgreSQL type: indexing, jsonpath queries, partial updates, validation |
| DB instead of files | Hot-reload without restart; inline procedures in scenario steps; referential integrity |
| Snapshot versioning | When starting a Scenario, versions of all used procedures are captured |

The snapshot approach guarantees predictability: no changes mid-execution. A new scenario run uses the current versions.

### Observability

Each command is an explicit unit of work, logged automatically:

| Component | Implementation |
|-----------|---------------|
| **Logging** | Structured JSON; masking of sensitive fields (password, token, secret, key) |
| **Metrics** | Prometheus: `procedure_executions_total`, `procedure_duration_seconds`, `command_executions_total`, `command_duration_seconds` |
| **Tracing** | OpenTelemetry: span per procedure + child spans per command; `trace_id` propagation in HTTP headers |

### Testing

| Method | Description |
|--------|-------------|
| **Dry-run** | Execution without side effects; `record.create` returns a fake ID, `notification.*` logs without sending |
| **Declarative tests** | Input, mocks, expected result, and expected commands in a JSON file |
| **Snapshot testing** | Comparing the result with a saved snapshot |

```json
{
  "name": "create_order creates an order and sends email",
  "procedure": "create_order",
  "input": {
    "customerId": "cust_123",
    "amount": 1500
  },
  "mocks": {
    "http": [
      { "url": "https://payment.com/charge", "response": { "status": 200, "body": { "paymentId": "pay_789" } } }
    ]
  },
  "expect": {
    "success": true,
    "result": { "orderId": { "type": "uuid" } },
    "commands": [
      { "type": "record.create", "object": "Order" },
      { "type": "notification.email", "template": "order_confirmed" }
    ]
  }
}
```

### Execution Result

A Procedure returns `ProcedureResult`:

```json
// Success
{
  "success": true,
  "result": { "accountId": "acc_123" },
  "error": null
}

// Error
{
  "success": false,
  "result": null,
  "error": {
    "code": "external_payment_declined",
    "message": "Payment was declined",
    "retryable": false
  }
}
```

### Evolutionary Path

```
Stage 1: Procedure Engine (MVP)
  +-- JSON DSL + Constructor UI + Expression Builder
  +-- Basic command types: record, notification, integration, compute, flow

Stage 2: Extended command types
  +-- New types as needs arise (batch, aggregate, approval)

Stage 3: Visual Flow Builder (optional)
  +-- Drag-and-drop graph on top of JSON for complex branching

Stage 4: Marketplace commands
  +-- Ready-made integrations (Slack, Stripe, 1C, Telegram)
```

## Consequences

### Positive

- **Constructor-first** — zero entry barrier: the administrator assembles a procedure through forms and dropdowns, without learning DSL
- **Expression Builder** — unified visual CEL expression constructor for all platform subsystems (procedures, validation rules, defaults, visibility)
- **JSON is native to the stack** — `encoding/json` (Go), JSONB (PostgreSQL), TypeScript — no additional parsers or dependencies
- **JSONB in PostgreSQL** — indexing, jsonpath queries, partial updates; ability to analyze procedures with SQL queries
- **Security by design** — sandbox without loops, arbitrary code, or file I/O; strict limits; OLS/FLS/RLS enforcement
- **Testability** — dry-run, declarative JSON tests, snapshot testing
- **Observability** — structured logging, Prometheus metrics, OpenTelemetry tracing for each command
- **Saga pattern** — LIFO rollback for compensating actions in distributed operations
- **Extensibility** — new command types are added in Go once, immediately available in Constructor

### Negative

- **Limited flexibility** — cannot express arbitrary algorithms; for non-standard scenarios, a new command type in Go is needed
- **Constructor is a frontend investment** — form-based UI for each command type requires developing Vue components
- **Expression Builder — implementation complexity** — visual CEL constructor with live preview, autocomplete, validation
- **JSON is less readable** — for power users working with raw JSON, it is less visual than YAML — compensated by Constructor UI
- **Dependency on CEL** — cel-go/cel-js become a critical platform dependency (but already adopted in ADR-0019)

## Related ADRs

- **ADR-0019** — Declarative business logic: CEL as expression language, validation rules, behavioral logic subsystems. Procedure Engine implements the procedural layer, complementing the declarative one. Expression Builder is reused across all subsystems
- **ADR-0020** — DML Pipeline Extension: all `record.*` commands execute through DML Engine with typed stages (defaults -> validate -> compute -> execute)
- **ADR-0022** — Object View: action type `procedure` in button configuration invokes Procedure Engine
- **ADR-0023** — Action terminology: establishes the terminology (Procedure, Command, Command Type) used in this ADR
- **ADR-0028** — Named Credentials: `integration.http` command uses the `credential` field for secure authentication. Replaces the `$.secrets` namespace
- **ADR-0029** — Versioning: Procedure definition is stored in `procedure_versions`, not inline. Draft/Published lifecycle. Scenario captures the version at start
